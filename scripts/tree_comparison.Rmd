---
title: "Tree Comparison"
output: html_document
params:
  tree1_path: "path/to/tree1.tre"
  tree2_path: "path/to/tree2.tre"
  summary_path: NULL
  cophylo_path: "path/to/figure.png"
  root: FALSE
  name: "default_name"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(ape)
library(phangorn)
library(ggtree)
library(ggplot2)
library(kableExtra)
library(phytools)

# Read the tree files
tree1 <- read.tree(params$tree1_path)
tree2 <- read.tree(params$tree2_path)
ifroot <- params$root

if (!ifroot) {
  tree1 <- unroot(tree1)
  tree2 <- unroot(tree2)
}

# Check if the taxa of the two trees are equal
taxa_equal <- setequal(tree1$tip.label, tree2$tip.label)
if (!taxa_equal) {
  taxa_diff1 <- setdiff(tree1$tip.label, tree2$tip.label)
  taxa_diff2 <- setdiff(tree2$tip.label, tree1$tip.label)
  cat("The taxa of the two trees are not equal.\n")
  cat("Number of taxa unique to Tree 1:", length(taxa_diff1), "\n")
  cat("Number of taxa unique to Tree 2:", length(taxa_diff2), "\n")
  cat("The differing taxa have been removed for the analysis.\n")
  tree1 <- drop.tip(tree1, taxa_diff1)
  tree2 <- drop.tip(tree2, taxa_diff2)
}

process_node_labels <- function(tree) {
  #' @description
  #' Process the node labels of a tree. Convert labels to numeric, scale if mean is less than 1, and convert back to character.
  #' @param tree A tree object read by the ape package.
  #' @return A tree object with processed node labels.

  # Convert node labels to numeric
  node_labels <- as.numeric(tree$node.label)

  # Check if the mean of numeric labels is less than 1
  if (mean(node_labels, na.rm = TRUE) < 1) {
    # Scale the labels by 100 and convert to integer
    node_labels <- as.integer(node_labels * 100)
  }

  # Convert back to character and replace the original labels
  tree$node.label <- as.character(node_labels)

  return(tree)
}

tree1 <- process_node_labels(tree1)
tree2 <- process_node_labels(tree2)

# Define a function to extract the tree name from the file path
extract_tree_name <- function(file_path) {
  # Remove the directory path and file extension from the file path
  tree_name <- sub("^.*\\/", "", file_path)
  tree_name <- sub("\\..*$", "", tree_name)
  return(tree_name)
}

# Extract tree names from file paths
tree1_name <- extract_tree_name(params$tree1_path)
tree2_name <- extract_tree_name(params$tree2_path)
```

## Tree Topology

### Table of topological distance metrics
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Calculate distances
RF_dist <- round(RF.dist(tree1, tree2, normalize = FALSE, check.labels = TRUE, rooted = ifroot), 4)
nRF_dist <- round(RF.dist(tree1, tree2, normalize = TRUE, check.labels = TRUE, rooted = ifroot), 4)
wRF_dist <- round(wRF.dist(tree1, tree2, normalize = FALSE, check.labels = TRUE, rooted = ifroot), 4)
KF_dist <- round(KF.dist(tree1, tree2, check.labels = TRUE, rooted = ifroot), 4)
SPR_dist <- round(SPR.dist(tree1, tree2), 4)
path_dist <- round(path.dist(tree1, tree2, check.labels = TRUE, use.weight = TRUE), 4)

# Calculate tree length
tree1_bl <- sum(tree1$edge.length)
tree2_bl <- sum(tree2$edge.length)
bl_diff_pct <- (tree2_bl - tree1_bl) / tree1_bl * 100

# Create a data frame with the results
result_df <- data.frame(
  "name" = params$name,
  "Tree1" = tree1_name,
  "Tree2" = tree2_name,
  "RF_dist" = RF_dist,
  "nRF" = nRF_dist,
  "wRF" = wRF_dist,
  "KF dist" = KF_dist,
  "SPR dist" = SPR_dist,
  "Path_dist" = path_dist,
  "Tree1_BL" = tree1_bl,
  "Tree2_BL" = tree2_bl,
  "BL_diff_per" = bl_diff_pct
)

# Print the resulting data frame
kable_styling(knitr::kable(result_df, caption = "Tree distance Summary", row.names = FALSE), bootstrap_options = c("striped", "hover", "condensed"))

if (!is.null(params$summary_path) && file.exists(params$summary_path)) {
  if (!file.exists(params$summary_path)) {
    write.table(result_df, file = params$summary_path, sep = ",", row.names = FALSE, col.names = TRUE)
  } else {
    # Read existing data
    existing_data <- read.table(params$summary_path, sep = ",", header = TRUE)
    # Combine existing data with new data
    combined_data <- rbind(existing_data, result_df)
    # Write combined data to file
    write.table(combined_data, file = params$summary_path, sep = ",", row.names = FALSE, col.names = TRUE)
  }
}
```

### Tree Visualization
```{r echo=FALSE, fig.height=25, fig.width=15, message=FALSE, warning=FALSE}
phylograms <- function(tree, y_scale = -5, subtitle = "") {
  ggtree(tree, cex = 0.8, lwd = 0.5, aes(color = ifelse(is.na(as.numeric(label)), 100, as.numeric(label)))) +
    scale_color_continuous(
      high = "black", low = "red",
      name = "Support Value", limits = c(0, 100),
      guide = guide_colourbar(barwidth = 10)
    ) +
    geom_treescale(y = y_scale - 20, color = "black", fontsize = 5) +
    labs(subtitle = subtitle) +
    theme(legend.position = "bottom")
}

p1 <- phylograms(tree1, subtitle = "Tree 1")
p2 <- phylograms(tree2, subtitle = "Tree 2")

multiplot(p1, p2, ncol = 2)
```

### Facet Cophylo plot
```{r echo=FALSE, message=FALSE, warning=FALSE}
generate_cophylo_plot <- function(rooted_tree1, rooted_tree2, output_path) {
  # Create cophylo object
  obj <- cophylo(rooted_tree1, rooted_tree2)

  # Calculate figure dimensions
  Nspecies <- length(rooted_tree1$tip.label)
  fig_length <- Nspecies %/% 15
  fig_width <- 12 + Nspecies %/% 100

  # Open pdf device with reduced resolution
  pdf(output_path, width = fig_width, height = fig_length, pointsize = 8)

  # Function to determine if node labels should be multiplied by 100
  should_multiply_by_100 <- function(labels) {
    numeric_labels <- as.numeric(labels)
    # Check if more than half of the labels are less than 1
    return(mean(numeric_labels < 1, na.rm = TRUE) > 0.5)
  }

  # Function to process bootstrap proportions and add edge labels
  add_edge_labels <- function(tree, position) {
    node_labels <- tree$node.label
    multiply_by_100 <- should_multiply_by_100(node_labels)

    bs <- sapply(tree$edge[, 2] - Ntip(tree),
      function(x, y) {
        if (x >= 2) {
          value <- as.numeric(y[x])
          if (multiply_by_100) {
            return(value * 100)
          } else {
            return(value)
          }
        } else {
          return("")
        }
      },
      y = node_labels
    )

    edgelabels.cophylo(bs, frame = "none", cex = 0.5, adj = c(0.4, -0.2), which = position)
  }

  # Function to create a color gradient based on support values
  create_edge_colors <- function(tree) {
    node_labels <- as.numeric(tree$node.label)
    support_values <- sapply(tree$edge[, 2] - Ntip(tree),
      function(x, y) {
        if (x >= 2) {
          return(as.numeric(y[x]))
        } else {
          return(NA)
        }
      },
      y = node_labels
    )

    # Create color gradient from red to black
    create_rgb_color <- function(value) {
      if (is.na(value)) {
        return(rgb(0, 0, 0, maxColorValue = 255))
      }
      red <- 255
      green <- 0
      blue <- 0
      # Interpolate from red to black
      red <- red * (1 - value)
      green <- green * (1 - value)
      blue <- blue * (1 - value)
      return(rgb(red, green, blue, maxColorValue = 255))
    }

    edge_colors <- sapply(support_values / 100, create_rgb_color)

    return(edge_colors)
  }

  # Create edge colors for both trees
  edge_colors <- list(
    left = create_edge_colors(obj$trees[[1]]),
    right = create_edge_colors(obj$trees[[2]])
  )

  # Plot cophylo with edge colors and without node or edge labels
  plot(obj, type = c("phylogram", "phylogram"), fsize = 0.3, part = 0.45, show.tip.label = FALSE, link.type = "curved", use.edge.length = TRUE, edge.col = edge_colors)

  # Apply the function to both trees
  add_edge_labels(obj$trees[[1]], "left")
  add_edge_labels(obj$trees[[2]], "right")

  # Close PDF device
  dev.off()
}

if (result_df$nRF >= 0.05) {
  # Generate cophylo plot
  output_path <- params$cophylo_path
  generate_cophylo_plot(tree1, tree2, output_path)
  cat("Cophylo plot generated successfully.\n")
  cat("![Cophylo plot](cophylo_plot.png)")
} else {
  cat("The normalized Robinson-Foulds distance is less than 0.05, cophylo plot will not be shown.")
}
```

## Branch Lengths Analysis

### Branch length Summary
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Calculate tree statistics
tree_stats <- function(tree, tree_name) {
  total_length <- sum(tree$edge.length)
  internal_lengths <- sum(tree$edge.length[tree$edge[, 2] <= length(tree$tip.label)])
  prop_internal <- internal_lengths / total_length
  summary_stats <- summary(tree$edge.length)
  c(
    Tree = tree_name,
    Tree_Length = round(total_length, 4),
    Sum_int = round(internal_lengths, 4),
    prop_int = round(prop_internal, 4),
    round(summary_stats, 4)
  )
}

# Calculate stats for both trees
stats_tree1 <- tree_stats(tree1, tree_name = tree1_name)
stats_tree2 <- tree_stats(tree2, tree_name = tree2_name)

# Combine into a data frame
tree_summary <- rbind(stats_tree1, stats_tree2)
rownames(tree_summary) <- NULL

kable_styling(knitr::kable(tree_summary, caption = "Branch length Summary"), bootstrap_options = c("striped", "hover", "condensed"))
```

### Faceted histogram
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=5}
# Load branch length data
branch_length_data <- data.frame(
  tree = rep(c(tree1_name, tree2_name), each = length(tree1$edge.length)),
  branch_length = c(tree1$edge.length, tree2$edge.length)
)

# Create a faceted histogram
ggplot(branch_length_data, aes(x = branch_length)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
  facet_grid(tree ~ ., scales = "free_y") +
  labs(x = "Branch Length", y = "Frequency") +
  theme_minimal() +
  scale_x_log10()
```

### ECDF plot
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=7, fig.height=4}
# Create an ECDF plot
ggplot(branch_length_data, aes(x = branch_length, color = tree)) +
  stat_ecdf(geom = "step") +
  labs(x = "Branch Length", y = "ECDF") +
  scale_color_manual(values = c(tree1_name = "blue", tree2_name = "red")) +
  theme_minimal() +
  theme(legend.position = "top") +
  scale_x_log10()
```

## Support value analysis

### Support value Summary
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Function to calculate node label statistics
node_label_stats <- function(node_labels, tree_name) {
  node_labels <- as.numeric(node_labels)
  node_labels <- node_labels[!is.na(node_labels)]

  # Scale if mean is less than 1
  if (mean(node_labels) < 1) {
    node_labels <- node_labels * 100
  }

  mean_label <- mean(node_labels)
  var_label <- var(node_labels)
  prop_le_10 <- mean(node_labels <= 10)
  prop_le_50 <- mean(node_labels <= 50)
  prop_le_90 <- mean(node_labels <= 90)

  c(
    Tree = tree_name,
    Mean = round(mean_label, 2),
    Variance = round(var_label, 2),
    Prop_LE_10 = round(prop_le_10, 2),
    Prop_LE_50 = round(prop_le_50, 2),
    Prop_LE_90 = round(prop_le_90, 2)
  )
}

# Calculate node label stats for both trees
node_label_stats_tree1 <- node_label_stats(tree1$node.label, tree_name = tree1_name)
node_label_stats_tree2 <- node_label_stats(tree2$node.label, tree_name = tree2_name)

# Combine into a data frame
node_label_summary <- rbind(node_label_stats_tree1, node_label_stats_tree2)
rownames(node_label_summary) <- NULL

kable_styling(knitr::kable(node_label_summary, caption = "Support value Statistics"), bootstrap_options = c("striped", "hover", "condensed"))
```

### Density plot of Support value
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=11, fig.height=4}
# Function to process node labels
convert_node_labels <- function(tree) {
  # Remove non-numeric labels
  node_labels <- as.numeric(tree$node.label)
  node_labels <- node_labels[!is.na(node_labels)]

  # Scale if mean is less than 1
  if (mean(node_labels) < 1) {
    node_labels <- node_labels * 100
  }

  return(node_labels)
}

# Process node labels for both trees
node_labels_tree1 <- convert_node_labels(tree1)
node_labels_tree2 <- convert_node_labels(tree2)

# Create a data frame for plotting
node_labels_data <- data.frame(
  tree = c(rep(tree1_name, length(node_labels_tree1)), rep(tree2_name, length(node_labels_tree2))),
  node_label = c(node_labels_tree1, node_labels_tree2)
)

# Create a density plot
ggplot(node_labels_data, aes(x = node_label, fill = tree)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_blank()
  ) +
  labs(
    title = "Density Plot of Support Values",
    x = "Support Values", y = "Density"
  )
```
